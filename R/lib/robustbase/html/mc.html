<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Medcouple, a Robust Measure of Skewness</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mc {robustbase}"><tr><td>mc {robustbase}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Medcouple, a Robust Measure of Skewness</h2>

<h3>Description</h3>

<p>Compute the &lsquo;medcouple&rsquo;, a <em>robust</em> concept and estimator
of skewness.  The medcouple is defined as a scaled median difference
of the left and right half of distribution, and hence <em>not</em> based
on the third moment as the classical skewness.
</p>


<h3>Usage</h3>

<pre>
mc(x, na.rm = FALSE, doReflect = (length(x) &lt;= 100),
   doScale = TRUE,               # &lt;- chg default to 'FALSE' ?
   eps1 = 1e-14, eps2 = 1e-15,   # &lt;&lt; new in 0.93-2 (2018-07..)
   maxit = 100, trace.lev = 0, full.result = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr valign="top"><td><code>na.rm</code></td>
<td>
<p>logical indicating how missing values (<code><a href="../../base/html/NA.html">NA</a></code>s)
should be dealt with.</p>
</td></tr>
<tr valign="top"><td><code>doReflect</code></td>
<td>
<p>logical indicating if the internal MC should also be
computed on the <em>reflected</em> sample <code>-x</code>, with final result
<code>(mc.(x) - mc.(-x))/2</code>.  This makes sense since the internal
MC, <code>mc.()</code> computes the himedian() which can differ slightly from
the median.</p>
</td></tr></table>

<table summary="R argblock">
<tr valign="top"><td><code>doScale</code></td>
<td>
<p>logical indicating if the internal algorithm should
also <em>scale</em> the data (using the most distant value from the
median which is unrobust and numerically dangerous); scaling has been
the hardwired default in the original algorithm and in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s
<code>mc()</code> till summer 2018.</p>
</td></tr>
<tr valign="top"><td><code>eps1, eps2</code></td>
<td>
<p>tolerance in the algorithm; only change with care!</p>
</td></tr>
<tr valign="top"><td><code>maxit</code></td>
<td>
<p>maximul number of iterations; typically a few should be
sufficient.</p>
</td></tr>
<tr valign="top"><td><code>trace.lev</code></td>
<td>
<p>integer specifying how much diagnostic output the
algorithm (in C) should produce.  No output by default, most output
for <code>trace.lev = 5</code>.</p>
</td></tr>
<tr valign="top"><td><code>full.result</code></td>
<td>
<p>logical indicating if the full return values (from
C) should be returned as a list via <code>attr(*, "mcComp")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number between -1 and 1, which is the medcouple, <i>MC(x)</i>.
For <code>r &lt;- mc(x, full.result = TRUE, ....)</code>, then
<code>attr(r, "mcComp")</code> is a list with components
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>medc</code></td>
<td>
<p>the medcouple  <i>mc.(x)</i>.</p>
</td></tr>
<tr valign="top"><td><code>medc2</code></td>
<td>
<p>the medcouple <i>mc.(-x)</i> if <code>doReflect=TRUE</code>.</p>
</td></tr>
<tr valign="top"><td><code>eps</code></td>
<td>
<p>tolerances used.</p>
</td></tr>
<tr valign="top"><td><code>iter,iter2</code></td>
<td>
<p>number of iterations used.</p>
</td></tr>
<tr valign="top"><td><code>converged,converged2</code></td>
<td>
<p>logical specifying &ldquo;convergence&rdquo;.</p>
</td></tr>
</table>


<h3>Convergence Problems</h3>

<p>For extreme cases there <em>are</em> convergence problems.
</p>
<p>Some of them can be alleviated by &ldquo;loosening&rdquo; the tolerances
<code>eps1</code> and <code>eps2</code>.
<br />
For others, with pecular values, notably many almost-ties with the
median, it can help extremely to replace <code>mc(x, *)</code> by
<code>mc(jitter(x), *)</code>.
</p>
<p>Also, the algorithm not only centers the data around the median but
also scales them by the extremes which may have a negative effect
e.g., when changing an extreme outlier to even more extreme, the
result changes wrongly; see the 'mc10x' example.
</p>


<h3>Author(s)</h3>

<p>Guy Brys; modifications by Tobias Verbeke and bug fixes and
extensions by Manuel Koller and Martin Maechler.
</p>


<h3>References</h3>

<p>Guy Brys, Mia Hubert and Anja Struyf (2004)
A Robust Measure of Skewness;
<em>JCGS</em> <b>13</b> (4), 996&ndash;1017.
</p>
<p>Hubert, M. and Vandervieren, E. (2008).
An adjusted boxplot for skewed distributions,
<em>Computational Statistics and Data Analysis</em> <b>52</b>, 5186&ndash;5201.
</p>


<h3>See Also</h3>

<p><code><a href="Qn.html">Qn</a></code> for a robust measure of scale (aka
&ldquo;dispersion&rdquo;), ....
</p>


<h3>Examples</h3>

<pre>
mc(1:5) # 0 for a symmetric sample

x1 &lt;- c(1, 2, 7, 9, 10)
mc(x1) # = -1/3

data(cushny)
mc(cushny) # 0.125

stopifnot(mc(c(-20, -5, -2:2, 5, 20)) == 0,
          mc(x1, doReflect=FALSE) ==  -mc(-x1, doReflect=FALSE),
          all.equal(mc(x1, doReflect=FALSE), -1/3, tolerance = 1e-12))

## Susceptibility of the current algorithm to large outliers :
dX10 &lt;- function(X) c(1:5,7,10,15,25, X) # generate skewed size-10 with 'X'
x &lt;- c(10,20,30, 100^(1:20))
(mc10x &lt;- vapply(x, function(X) mc(dX10(X)), 1))
## limit X -&gt; Inf  should be 7/12 = 0.58333...  but that "breaks down a bit" :
plot(x, mc10x, type="b", main = "mc( c(1:5,7,10,15,25, X) )", xlab="X", log="x")
</pre>

<hr /><div style="text-align: center;">[Package <em>robustbase</em> version 0.93-3 <a href="00Index.html">Index</a>]</div>
</body></html>
