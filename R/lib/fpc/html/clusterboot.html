<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Clusterwise cluster stability assessment by resampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for clusterboot {fpc}"><tr><td>clusterboot {fpc}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Clusterwise cluster stability assessment by resampling</h2>

<h3>Description</h3>

<p>Assessment of the clusterwise stability of a clustering of data, which
can be cases*variables or dissimilarity data. The data is resampled
using several schemes (bootstrap, subsetting, jittering, replacement
of points by noise) and the Jaccard similarities of the original
clusters to the most similar clusters in the resampled data are
computed. The mean over these similarities is used as an index of the
stability of a cluster (other statistics can be computed as well). The
methods are described in Hennig (2007).
</p>
<p><code>clusterboot</code> is an integrated function that computes the
clustering as well, using interface functions for various
clustering methods implemented in R (several interface functions are
provided, but you can
implement further ones for your favourite clustering method). See the
documentation of the input parameter <code>clustermethod</code> below.
</p>
<p>Quite general clustering methods are possible, i.e. methods estimating
or fixing the number of clusters, methods producing overlapping
clusters or not assigning all cases to clusters (but declaring them as
&quot;noise&quot;). Fuzzy clusterings cannot be processed and have to be
transformed to crisp clusterings by the interface function.  
</p>


<h3>Usage</h3>

<pre>
clusterboot(data,B=100, distances=(class(data)=="dist"),
                        bootmethod="boot",
                        bscompare=TRUE, 
                        multipleboot=FALSE,
                        jittertuning=0.05, noisetuning=c(0.05,4),
                        subtuning=floor(nrow(data)/2),
                        clustermethod,noisemethod=FALSE,count=TRUE,
                        showplots=FALSE,dissolution=0.5,
                        recover=0.75,seed=NULL,datatomatrix=TRUE,...)

## S3 method for class 'clboot'
print(x,statistics=c("mean","dissolution","recovery"),...)

## S3 method for class 'clboot'
plot(x,xlim=c(0,1),breaks=seq(0,1,by=0.05),...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>by default something that can be coerced into a
(numerical) matrix (data frames with non-numerical data are allowed
when using <code>datatomatrix=FALSE</code>, see below). The data matrix -
either an <code>n*p</code>-data matrix (or data frame) or an
<code>n*n</code>-dissimilarity matrix (or
<code>dist</code>-object).</p>
</td></tr>
<tr valign="top"><td><code>B</code></td>
<td>
<p>integer. Number of resampling runs for each scheme, see
<code>bootmethod</code>.</p>
</td></tr>
<tr valign="top"><td><code>distances</code></td>
<td>
<p>logical. If <code>TRUE</code>, the data is interpreted as
dissimilarity matrix. If <code>data</code> is a <code>dist</code>-object,
<code>distances=TRUE</code> automatically, otherwise
<code>distances=FALSE</code> by default. This means that you have to set
it to <code>TRUE</code> manually if <code>data</code> is a dissimilarity matrix.</p>
</td></tr>
<tr valign="top"><td><code>bootmethod</code></td>
<td>
<p>vector of strings, defining the methods used for
resampling. Possible methods:
</p>
<p><code>"boot"</code>: nonparametric bootstrap (precise behaviour is
controlled by parameters <code>bscompare</code> and
<code>multipleboot</code>).
</p>
<p><code>"subset"</code>: selecting random subsets from the dataset. Size
determined by <code>subtuning</code>.
</p>
<p><code>"noise"</code>: replacing a certain percentage of the points by
random noise, see <code>noisetuning</code> (note that this will not
work if within-cluster .
</p>
<p><code>"jitter"</code> add random noise to all points, see
<code>jittertuning</code>. (This didn't perform well in Hennig (2007),
but you may want to get your own experience.)
</p>
<p><code>"bojit"</code> nonparametric bootstrap first, and then adding
noise to the points, see <code>jittertuning</code>.
</p>
<p><strong>Important:</strong> only the methods <code>"boot"</code> and
<code>"subset"</code> work with dissimilarity data, or if
<code>datatomatrix=FALSE</code>!
</p>
<p>The results in Hennig (2007) indicate that <code>"boot"</code> is
generally informative and often quite similar to <code>"subset"</code> and
<code>"bojit"</code>, while <code>"noise"</code> sometimes provides different
information. Therefore the default (for <code>distances=FALSE</code>) is
to use <code>"boot"</code> and <code>"noise"</code>. However, some clustering
methods may have problems with multiple points, which can be solved
by using <code>"bojit"</code> or <code>"subset"</code> instead of <code>"boot"</code> or by
<code>multipleboot=FALSE</code> below.</p>
</td></tr>
<tr valign="top"><td><code>bscompare</code></td>
<td>
<p>logical. If <code>TRUE</code>, multiple points in the
bootstrap sample are taken into account to compute the Jaccard
similarity to the original clusters (which are represented by their
&quot;bootstrap versions&quot;, i.e., the
points of the original cluster which also occur in the bootstrap
sample). If a point was drawn more than once, it is in the &quot;bootstrap
version&quot; of the original cluster more than once, too, if
<code>bscompare=TRUE</code>. Otherwise multiple points are
ignored for the computation of the Jaccard similarities. If
<code>multipleboot=FALSE</code>, it doesn't make a difference.</p>
</td></tr> 
<tr valign="top"><td><code>multipleboot</code></td>
<td>
<p>logical. If <code>FALSE</code>, all points drawn more
than once in the bootstrap draw are only used once in the bootstrap
samples.</p>
</td></tr>
<tr valign="top"><td><code>jittertuning</code></td>
<td>
<p>positive numeric. Tuning for the
<code>"jitter"</code>-method. The noise distribution for
jittering is a normal distribution with zero mean. The covariance
matrix has the same Eigenvectors as that of the original
data set, but the standard deviation along the principal directions is
determined by the <code>jittertuning</code>-quantile of the distances
between neighboring points projected along these directions.</p>
</td></tr>
<tr valign="top"><td><code>noisetuning</code></td>
<td>
<p>A vector of two positive numerics. Tuning for the
<code>"noise"</code>-method. The first component determines the
probability that a point is replaced by noise. Noise is generated by
a uniform distribution on a hyperrectangle along the principal
directions of the original data set, ranging from
<code>-noisetuning[2]</code> to <code>noisetuning[2]</code> times the standard
deviation of the data set along the respective direction. Note that
only points not replaced by noise are considered for the computation
of Jaccard similarities.</p>
</td></tr>
<tr valign="top"><td><code>subtuning</code></td>
<td>
<p>integer. Size of subsets for <code>"subset"</code>.</p>
</td></tr>
<tr valign="top"><td><code>clustermethod</code></td>
<td>
<p>an interface function (the function name, not a
string containing the name, has to be provided!). This defines the
clustering method. See the &quot;Details&quot;-section for a list of available
interface functions and guidelines how to write your own ones. 
</p>
</td></tr>
<tr valign="top"><td><code>noisemethod</code></td>
<td>
<p>logical. If <code>TRUE</code>, the last cluster is
regarded as &quot;noise cluster&quot;, which means that for computing the Jaccard
similarity, it is not treated as a cluster. The noise cluster of
the original clustering is only compared with the noise cluster of
the clustering of the resampled data. This means that in the
<code>clusterboot</code>-output (and plot), if points were assigned to the
noise cluster, the last cluster number refers to it, and its
Jaccard similarity values refer to comparisons with estimated noise
components in resampled datasets only.
(Some cluster methods such as
trimmed k-means and <code><a href="../../mclust/html/mclustBIC.html">mclustBIC</a></code> produce such noise
components.)</p>
</td></tr>
<tr valign="top"><td><code>count</code></td>
<td>
<p>logical. If <code>TRUE</code>, the resampling runs are counted
on the screen.</p>
</td></tr>    
<tr valign="top"><td><code>showplots</code></td>
<td>
<p>logical. If <code>TRUE</code>, a plot of the first two
dimensions of the resampled data set (or the classical MDS solution
for dissimilarity data) is shown for every resampling run. The last
plot shows the original data set. Ignored if <code>datatomatrix=FALSE</code>.</p>
</td></tr>
<tr valign="top"><td><code>dissolution</code></td>
<td>
<p>numeric between 0 and 1. If the Jaccard similarity
between the resampling version of the original cluster and the most
similar cluster on the resampled data is smaller or equal to this
value, the cluster is considered as &quot;dissolved&quot;. Numbers of
dissolved clusters are recorded.</p>
</td></tr>
<tr valign="top"><td><code>recover</code></td>
<td>
<p>numeric between 0 and 1. If the Jaccard similarity
between the resampling version of the original cluster and the most
similar cluster on the resampled data is larger than  this
value, the cluster is considered as &quot;successfully recovered&quot;. Numbers of
recovered clusters are recorded.</p>
</td></tr>
<tr valign="top"><td><code>seed</code></td>
<td>
<p>integer. Seed for random generator (fed into
<code>set.seed</code>) to make results reproducible. If <code>NULL</code>,
results depend on chance.</p>
</td></tr>
<tr valign="top"><td><code>datatomatrix</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>data</code> is coerced
into a (numerical) matrix at the start of
<code>clusterboot</code>. <code>FALSE</code> may be chosen for mixed type data
including e.g. categorical factors (assuming that the chosen
<code>clustermethod</code> allows for this). This disables some features
of <code>clusterboot</code>, see parameters <code>bootmethod</code> and
<code>showplots</code>.</p>
</td></tr>  
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional parameters for the clustermethods called by
<code>clusterboot</code>. No effect in <code>print.clboot</code> and
<code>plot.clboot</code>.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>object of class <code>clboot</code>.</p>
</td></tr>
<tr valign="top"><td><code>statistics</code></td>
<td>
<p>specifies in <code>print.clboot</code>,
which of the three clusterwise Jaccard
similarity statistics <code>"mean"</code>, <code>"dissolution"</code> (number of
times the cluster has been dissolved) and <code>"recovery"</code> (number
of times a cluster has been successfully recovered) is printed.</p>
</td></tr>
<tr valign="top"><td><code>xlim</code></td>
<td>
<p>transferred to <code>hist</code>.</p>
</td></tr>
<tr valign="top"><td><code>breaks</code></td>
<td>
<p>transferred to <code>hist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here are some guidelines for interpretation.
There is some theoretical justification to consider a Jaccard
similarity value smaller or equal to 0.5 as an indication of a
&quot;dissolved cluster&quot;, see Hennig (2008). Generally, a valid, stable
cluster should yield a mean Jaccard similarity value of 0.75 or more.
Between 0.6 and 0.75, clusters may be considered as indicating
patterns in the data, but which points exactly should belong to these
clusters is highly doubtful. Below average Jaccard values of 0.6, clusters
should not be trusted. &quot;Highly stable&quot; clusters should yield average
Jaccard similarities of 0.85 and above. All of this refers to
bootstrap; for the other resampling schemes it depends on the tuning
constants, though their default values should grant similar
interpretations in most cases.
</p>
<p>While <code>B=100</code> is recommended, smaller run numbers could give
quite informative results as well, if computation times become too high.
</p>
<p>Note that the stability of a cluster is assessed, but
stability is not the only important validity criterion - clusters
obtained by very inflexible clustering methods may be stable but not
valid, as discussed in Hennig (2007).
See <code><a href="plotcluster.html">plotcluster</a></code> for graphical cluster validation.
</p>
<p>Information about interface functions for clustering methods:
</p>
<p>The following interface functions are currently
implemented (in the present package; note that almost all of these
functions require the specification of some control parameters, so
if you use one of them, look up their common help page
<code><a href="kmeansCBI.html">kmeansCBI</a></code>) first:
</p>

<dl>
<dt>kmeansCBI</dt><dd><p>an interface to the function
<code><a href="../../stats/html/kmeans.html">kmeans</a></code> for k-means clustering. This assumes a
cases*variables matrix as input.</p>
</dd>
<dt>hclustCBI</dt><dd><p>an interface to the function
<code>hclust</code> for agglomerative hierarchical clustering with
optional noise cluster. This
function produces a partition and assumes a cases*variables
matrix as input.</p>
</dd>
<dt>hclusttreeCBI</dt><dd><p>an interface to the function
<code>hclust</code> for agglomerative hierarchical clustering. This
function produces a tree (not only a partition; therefore the
number of clusters can be huge!) and assumes a cases*variables
matrix as input.</p>
</dd>
<dt>disthclustCBI</dt><dd><p>an interface to the function
<code>hclust</code> for agglomerative hierarchical clustering with
optional noise cluster. This
function produces a partition and assumes a dissimilarity
matrix as input.</p>
</dd>
<dt>noisemclustCBI</dt><dd><p>an interface to the function
<code><a href="../../mclust/html/mclustBIC.html">mclustBIC</a></code> for normal mixture model based
clustering. This assumes a cases*variables matrix as
input. Warning: <code><a href="../../mclust/html/mclustBIC.html">mclustBIC</a></code> sometimes has
problems with multiple
points. It is recommended to use this only together with
<code>multipleboot=FALSE</code>.</p>
</dd>
<dt>distnoisemclustCBI</dt><dd><p>an interface to the function
<code><a href="../../mclust/html/mclustBIC.html">mclustBIC</a></code> for normal mixture model based
clustering. This assumes a dissimilarity matrix as input and
generates a data matrix by multidimensional scaling first.
Warning: <code><a href="../../mclust/html/mclustBIC.html">mclustBIC</a></code> sometimes has
problems with multiple
points. It is recommended to use this only together with
<code>multipleboot=FALSE</code>.</p>
</dd>
<dt>claraCBI</dt><dd><p>an interface to the functions
<code><a href="../../cluster/html/pam.html">pam</a></code> and <code><a href="../../cluster/html/clara.html">clara</a></code>
for partitioning around medoids. This can be used with
cases*variables as well as dissimilarity matrices as input.</p>
</dd>
<dt>pamkCBI</dt><dd><p>an interface to the function
<code><a href="pamk.html">pamk</a></code> for partitioning around medoids. The number
of cluster is estimated by the average silhouette width.
This can be used with
cases*variables as well as dissimilarity matrices as input.</p>
</dd>
<dt>trimkmeansCBI</dt><dd><p>an interface to the function
<code><a href="../../trimcluster/html/trimkmeans.html">trimkmeans</a></code> for trimmed k-means
clustering. This assumes a cases*variables matrix as input.</p>
</dd>
<dt>tclustCBI</dt><dd><p>an interface to the function
<code>tclust</code> in the tclust library for trimmed Gaussian 
clustering. This assumes a cases*variables matrix as input. Note
that this function is not currently provided because the tclust
package is only available in the CRAN archives, but the code is
in the Examples-section of the <code><a href="kmeansCBI.html">kmeansCBI</a></code>-help page.</p>
</dd>
<dt>disttrimkmeansCBI</dt><dd><p>an interface to the function
<code><a href="../../trimcluster/html/trimkmeans.html">trimkmeans</a></code> for trimmed k-means
clustering. This assumes a dissimilarity matrix as input and
generates a data matrix by multidimensional scaling first.</p>
</dd>
<dt>dbscanCBI</dt><dd><p>an interface to the function
<code><a href="dbscan.html">dbscan</a></code> for density based 
clustering. This can be used with
cases*variables as well as dissimilarity matrices as input..</p>
</dd>
<dt>mahalCBI</dt><dd><p>an interface to the function
<code><a href="fixmahal.html">fixmahal</a></code> for fixed point
clustering. This assumes a cases*variables matrix as input.</p>
</dd>
<dt>mergenormCBI</dt><dd><p>an interface to the function
<code><a href="mergenormals.html">mergenormals</a></code> for clustering by merging Gaussian
mixture components.</p>
</dd>
<dt>speccCBI</dt><dd><p>an interface to the function
<code><a href="../../kernlab/html/specc.html">specc</a></code> for spectral clustering.</p>
</dd>
</dl>

<p>You can write your own interface function. The first argument of an
interface function should preferably be a data matrix (of class
&quot;matrix&quot;, but it may be a symmetrical dissimilarity matrix). It can
be a data frame, but this restricts some of the functionality of
<code>clusterboot</code>, see above. Further
arguments can be tuning constants for the clustering method. The
output of an interface function should be a list containing (at
least) the following components:
</p>

<dl>
<dt>result</dt><dd><p>clustering result, usually a list with the full
output of the clustering method (the precise format doesn't
matter); whatever you want to use later.</p>
</dd>
<dt>nc</dt><dd><p>number of clusters. If some points don't belong to any
cluster but are declared as &quot;noise&quot;, <code>nc</code> includes the
noise cluster, and there should be another component
<code>nccl</code>, being the number of clusters not including the
noise cluster (note that it is not mandatory to define a noise
component if not all points are assigned to clusters, but if you
do it, the stability of the noise cluster is assessed as
well.)</p>
</dd>
<dt>clusterlist</dt><dd><p>this is a list consisting of a logical vectors
of length of the number of data points (<code>n</code>) for each cluster,
indicating whether a point is a member of this cluster
(<code>TRUE</code>) or not. If a noise cluster is included, it
should always be the last vector in this list.</p>
</dd>
<dt>partition</dt><dd><p>an integer vector of length <code>n</code>,
partitioning the data. If the method produces a partition, it
should be the clustering. This component is only used for plots,
so you could do something like <code>rep(1,n)</code> for
non-partitioning methods. If a noise cluster is included,
<code>nc=nccl+1</code> and the noise cluster is cluster no. <code>nc</code>.</p>
</dd>
<dt>clustermethod</dt><dd><p>a string indicating the clustering method.</p>
</dd>
</dl>
      


<h3>Value</h3>

<p><code>clusterboot</code> returns an object of class <code>"clboot"</code>, which
is a list with components
<code>result, partition, nc, clustermethod, B, noisemethod, bootmethod,
    multipleboot, dissolution, recover, bootresult, bootmean, bootbrd,
    bootrecover, jitterresult, jittermean, jitterbrd, jitterrecover,
    subsetresult, subsetmean, subsetbrd, subsetrecover, bojitresult,
    bojitmean, bojitbrd, bojitrecover, noiseresult, noisemean, 
    noisebrd, noiserecover</code>.
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>result</code></td>
<td>
<p>clustering result; full output of the selected
<code>clustermethod</code> for the original data set.</p>
</td></tr>
<tr valign="top"><td><code>partition</code></td>
<td>
<p>partition parameter of the selected <code>clustermethod</code>
(note that this is only meaningful for partitioning clustering methods).</p>
</td></tr>
<tr valign="top"><td><code>nc</code></td>
<td>
<p>number of clusters in original data (including noise
component if <code>noisemethod=TRUE</code>).</p>
</td></tr>
<tr valign="top"><td><code>nccl</code></td>
<td>
<p>number of clusters in original data (not including noise
component if <code>noisemethod=TRUE</code>).</p>
</td></tr>
<tr valign="top"><td><code>clustermethod, B, noisemethod, bootmethod, multipleboot, dissolution,
recover</code></td>
<td>
<p>input parameters, see above.</p>
</td></tr>
<tr valign="top"><td><code>bootresult</code></td>
<td>
<p>matrix of Jaccard similarities for
<code>bootmethod="boot"</code>. Rows correspond to clusters in the
original data set. Columns correspond to bootstrap runs.</p>
</td></tr>
<tr valign="top"><td><code>bootmean</code></td>
<td>
<p>clusterwise means of the <code>bootresult</code>.</p>
</td></tr>
<tr valign="top"><td><code>bootbrd</code></td>
<td>
<p>clusterwise number of times a cluster has been dissolved.</p>
</td></tr>
<tr valign="top"><td><code>bootrecover</code></td>
<td>
<p>clusterwise number of times a cluster has been
successfully recovered.</p>
</td></tr>
<tr valign="top"><td><code>subsetresult, subsetmean, etc.</code></td>
<td>
<p>same as <code>bootresult,
      bootmean, etc.</code>, but for the other resampling methods.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:c.hennig@ucl.ac.uk">c.hennig@ucl.ac.uk</a>
<a href="http://www.homepages.ucl.ac.uk/~ucakche/">http://www.homepages.ucl.ac.uk/~ucakche/</a>
</p>


<h3>References</h3>

<p>Hennig, C. (2007) Cluster-wise assessment of cluster
stability. <em>Computational Statistics and Data Analysis</em>,
52, 258-271.
</p>
<p>Hennig, C. (2008)  Dissolution point and isolation robustness:
robustness criteria for general cluster analysis methods.
<em>Journal of Multivariate Analysis</em> 99, 1154-1176.
</p>


<h3>See Also</h3>

<p><code><a href="../../stats/html/dist.html">dist</a></code>,
interface functions:
<code><a href="kmeansCBI.html">kmeansCBI</a></code>, <code><a href="kmeansCBI.html">hclustCBI</a></code>,
<code><a href="kmeansCBI.html">hclusttreeCBI</a></code>, <code><a href="kmeansCBI.html">disthclustCBI</a></code>,
<code><a href="kmeansCBI.html">noisemclustCBI</a></code>, <code><a href="kmeansCBI.html">distnoisemclustCBI</a></code>,
<code><a href="kmeansCBI.html">claraCBI</a></code>, <code><a href="kmeansCBI.html">pamkCBI</a></code>,
<code><a href="kmeansCBI.html">trimkmeansCBI</a></code>, <code><a href="kmeansCBI.html">disttrimkmeansCBI</a></code>,
<code><a href="kmeansCBI.html">dbscanCBI</a></code>, <code><a href="kmeansCBI.html">mahalCBI</a></code>
</p>


<h3>Examples</h3>

<pre>
  options(digits=3)
  set.seed(20000)
  face &lt;- rFace(50,dMoNo=2,dNoEy=0,p=2)
  cf1 &lt;- clusterboot(face,B=3,bootmethod=
          c("boot","noise","jitter"),clustermethod=kmeansCBI,
          krange=5,seed=15555)

  print(cf1)
  plot(cf1)


  cf2 &lt;- clusterboot(dist(face),B=3,bootmethod=
          "subset",clustermethod=disthclustCBI,
          k=5, cut="number", method="average", showplots=TRUE, seed=15555)
  print(cf2)
  d1 &lt;- c("a","b","a","c")
  d2 &lt;- c("a","a","a","b")
  dx &lt;- as.data.frame(cbind(d1,d2))
  cpx &lt;- clusterboot(dx,k=2,B=10,clustermethod=claraCBI,
          multipleboot=TRUE,usepam=TRUE,datatomatrix=FALSE)
  print(cpx)
</pre>

<hr /><div style="text-align: center;">[Package <em>fpc</em> version 2.1-11.1 <a href="00Index.html">Index</a>]</div>
</body></html>
