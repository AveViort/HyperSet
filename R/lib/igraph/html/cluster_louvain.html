<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Finding community structure by multi-level optimization of...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for cluster_louvain {igraph}"><tr><td>cluster_louvain {igraph}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Finding community structure by multi-level optimization of modularity</h2>

<h3>Description</h3>

<p>This function implements the multi-level modularity optimization algorithm
for finding community structure, see references below. It is based on the
modularity measure and a hierarchial approach.
</p>


<h3>Usage</h3>

<pre>
cluster_louvain(graph, weights = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>Optional positive weight vector.  If the graph has a
<code>weight</code> edge attribute, then this is used by default. Supply <code>NA</code>
here if the graph has a <code>weight</code> edge attribute, but you want to ignore
it. Larger edge weights correspond to stronger connections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the multi-level modularity optimization algorithm
for finding community structure, see VD Blondel, J-L Guillaume, R Lambiotte
and E Lefebvre: Fast unfolding of community hierarchies in large networks,
<a href="http://arxiv.org/abs/arXiv:0803.0476">http://arxiv.org/abs/arXiv:0803.0476</a> for the details.
</p>
<p>It is based on the modularity measure and a hierarchial approach.
Initially, each vertex is assigned to a community on its own. In every step,
vertices are re-assigned to communities in a local, greedy way: each vertex
is moved to the community with which it achieves the highest contribution to
modularity. When no vertices can be reassigned, each community is considered
a vertex on its own, and the process starts again with the merged
communities. The process stops when there is only a single vertex left or
when the modularity cannot be increased any more in a step.
</p>
<p>This function was contributed by Tom Gregorovic.
</p>


<h3>Value</h3>

<p><code>cluster_louvain</code> returns a <code><a href="communities.html">communities</a></code>
object, please see the <code><a href="communities.html">communities</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Tom Gregorovic, Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Vincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte,
Etienne Lefebvre: Fast unfolding of communities in large networks. J. Stat.
Mech. (2008) P10008
</p>


<h3>See Also</h3>

<p>See <code><a href="communities.html">communities</a></code> for extracting the membership,
modularity scores, etc. from the results.
</p>
<p>Other community detection algorithms: <code><a href="cluster_walktrap.html">cluster_walktrap</a></code>,
<code><a href="cluster_spinglass.html">cluster_spinglass</a></code>,
<code><a href="cluster_leading_eigen.html">cluster_leading_eigen</a></code>,
<code><a href="cluster_edge_betweenness.html">cluster_edge_betweenness</a></code>,
<code><a href="cluster_fast_greedy.html">cluster_fast_greedy</a></code>,
<code><a href="cluster_label_prop.html">cluster_label_prop</a></code>
</p>


<h3>Examples</h3>

<pre>

# This is so simple that we will have only one level
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1,6, 1,11, 6, 11))
cluster_louvain(g)

</pre>

<hr /><div style="text-align: center;">[Package <em>igraph</em> version 1.2.2 <a href="00Index.html">Index</a>]</div>
</body></html>
