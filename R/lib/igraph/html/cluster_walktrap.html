<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Community strucure via short random walks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for cluster_walktrap {igraph}"><tr><td>cluster_walktrap {igraph}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Community strucure via short random walks</h2>

<h3>Description</h3>

<p>This function tries to find densely connected subgraphs, also called
communities in a graph via random walks. The idea is that short random walks
tend to stay in the same community.
</p>


<h3>Usage</h3>

<pre>
cluster_walktrap(graph, weights = E(graph)$weight, steps = 4,
  merges = TRUE, modularity = TRUE, membership = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>graph</code></td>
<td>
<p>The input graph, edge directions are ignored in directed
graphs.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>The edge weights. Larger edge weights increase the
probability that an edge is selected by the random walker. In other
words, larger edge weights correspond to stronger connections.</p>
</td></tr>
<tr valign="top"><td><code>steps</code></td>
<td>
<p>The length of the random walks to perform.</p>
</td></tr>
<tr valign="top"><td><code>merges</code></td>
<td>
<p>Logical scalar, whether to include the merge matrix in the
result.</p>
</td></tr>
<tr valign="top"><td><code>modularity</code></td>
<td>
<p>Logical scalar, whether to include the vector of the
modularity scores in the result. If the <code>membership</code> argument is true,
then it will be always calculated.</p>
</td></tr>
<tr valign="top"><td><code>membership</code></td>
<td>
<p>Logical scalar, whether to calculate the membership vector
for the split corresponding to the highest modularity value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the implementation of the Walktrap community finding
algorithm, see Pascal Pons, Matthieu Latapy: Computing communities in large
networks using random walks, http://arxiv.org/abs/physics/0512106
</p>


<h3>Value</h3>

<p><code>cluster_walktrap</code> returns a <code><a href="communities.html">communities</a></code>
object, please see the <code><a href="communities.html">communities</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Pascal Pons (<a href="http://psl.pons.free.fr/">http://psl.pons.free.fr/</a>) and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R and igraph interface
</p>


<h3>References</h3>

<p>Pascal Pons, Matthieu Latapy: Computing communities in large
networks using random walks, http://arxiv.org/abs/physics/0512106
</p>


<h3>See Also</h3>

<p>See <code><a href="communities.html">communities</a></code> on getting the actual membership
vector, merge matrix, modularity score, etc.
</p>
<p><code><a href="modularity.igraph.html">modularity</a></code> and <code><a href="cluster_fast_greedy.html">cluster_fast_greedy</a></code>,
<code><a href="cluster_spinglass.html">cluster_spinglass</a></code>,
<code><a href="cluster_leading_eigen.html">cluster_leading_eigen</a></code>,
<code><a href="cluster_edge_betweenness.html">cluster_edge_betweenness</a></code> for other community detection
methods.
</p>


<h3>Examples</h3>

<pre>

g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1,6, 1,11, 6, 11))
cluster_walktrap(g)

</pre>

<hr /><div style="text-align: center;">[Package <em>igraph</em> version 1.2.2 <a href="00Index.html">Index</a>]</div>
</body></html>
