<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Benchmark networks using Network Enrichment Analysis (NEA)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for benchmark {NEArender}"><tr><td>benchmark {NEArender}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Benchmark networks using Network Enrichment Analysis (NEA)</h2>

<h3>Description</h3>

<p>Tests the ability of a given network to perform well in a network enrichment analysis. It executes a series of multiple individual tests: for each member gene of a pathway or another functional set calculates the network enrichment score against other members of the same gene set. This procedure gives true positive and false negative test results. In order to complement it with false positives and true negatives, the same is done for randomly picked genes (with matching node connectivity values) against the same functional sets. The two vectors allow plotting a ROC curve where at each sequential cutoff represents a ratio of true positive vs. false positive predictions. This approach (first presented in  <a href="http://www.biomedcentral.com/1471-2105/15/308">Merid et al. (2012)</a>) is an alternative to the trivial counting edges shared between different networks  and is superior to the latter because: 1) the analysis can be done without knowing the &quot;true&quot; reference network, 2) benchmarks can be context-dependent by using domain-specific test sets (e.g. cancer, diabetes etc.), 3) one can compare more than two networks at a time, and 4) given dense global networks and due to the use of multi-gene sets, presence or absence of particular links is unlikely to affect the overall result.
</p>


<h3>Usage</h3>

<pre>
benchmark(NET, GS, gs.gene.col = 2, gs.group.col = 3, net.gene1.col = 1,
  net.gene2.col = 2, echo = 1, graph = FALSE, na.replace = 0,
  mask = ".", minN = 0, coff.z = 1.965, coff.fdr = 0.1,
  Parallelize = 1)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>NET</code></td>
<td>
<p>A network to benchmark. See Details in <code><a href="nea.render.html">nea.render</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>GS</code></td>
<td>
<p>a test set, typically a set of pathways with known members.</p>
</td></tr>
<tr valign="top"><td><code>gs.gene.col</code></td>
<td>
<p>number of the column containing GS genes (only needed if GS is submitted as a text file)</p>
</td></tr>
<tr valign="top"><td><code>gs.group.col</code></td>
<td>
<p>number of the column containing group IDs (only needed if GS is submitted as a text file)</p>
</td></tr>
<tr valign="top"><td><code>net.gene1.col</code></td>
<td>
<p>number of the column containing first nodes of each network edge (only needed if NET is submitted as a text file)</p>
</td></tr>
<tr valign="top"><td><code>net.gene2.col</code></td>
<td>
<p>number of the column containing second nodes of each network edge (only needed if NET is submitted as a text file)</p>
</td></tr>
<tr valign="top"><td><code>echo</code></td>
<td>
<p>if messages about execution progress should appear</p>
</td></tr>
<tr valign="top"><td><code>graph</code></td>
<td>
<p>Plot the ROC curve immediately. Alternatively, the returned list is plotted afterwards by <code><a href="roc.html">roc</a></code>. In the latter case, it could be a combined list of lists for multiple test sets and networks which are then plotted as separate curves (see Examples).</p>
</td></tr>
<tr valign="top"><td><code>na.replace</code></td>
<td>
<p>replace NA values. Default=0, i.e. do not replace.</p>
</td></tr>
<tr valign="top"><td><code>mask</code></td>
<td>
<p>when the test set contains various GSs, they can be used selectively by applying a mask. The mask follows the regular expression synthax, since <code>fixed=FALSE</code> in <code><a href="../../base/html/grep.html">grep</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>minN</code></td>
<td>
<p>the minimal number of network edges that must connect a tested member with the GS genes for the test to be considered positive. (Default:0).</p>
</td></tr>
<tr valign="top"><td><code>coff.z</code></td>
<td>
<p>a parameter to <code><a href="roc.html">roc</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>coff.fdr</code></td>
<td>
<p>to make significance levels comparable between different curves, the point where FDR=<code>coff.fdr</code> will be labeled with a circle (think of TP/FP ratio at this level).</p>
</td></tr>
<tr valign="top"><td><code>Parallelize</code></td>
<td>
<p>The number of CPU cores to be used for the step &quot;Counting actual links&quot; (while the other steps are sufficiently fast). The option is not supported in Windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function would either plot a ROC curve for the analyzed network, or return an object with the following slots from function prediction (package ROCR):<br />
tp, vector of true positives;<br />
fp, vector of false positives;<br />
tn, vector of true negatives;<br />
fn, vector of false negatives;<br />
cutoffs, z-score cutoffs from <code>nea.render</code>;<br />
cross.z, a z-score value which corresponds to FDR=<code>coff.fdr</code> (will be denoted with a special marker at the curve);
</p>


<h3>Value</h3>

<p>An object, i.e. a list of three equal-length vectors from a <code><a href="../../ROCR/html/prediction.html">prediction</a></code> object of ROCR package (<code>prediction@cutoffs</code>, <code>prediction@fp</code>, <code>prediction@tp</code>) and the point that matches <code>coff.fdr</code>. These are needed to plot a ROC curve for the given network and test set by using <code><a href="roc.html">roc</a></code>.
</p>


<h3>References</h3>

<p><a href="http://www.biomedcentral.com/1471-2105/15/308">http://www.biomedcentral.com/1471-2105/15/308</a>
</p>


<h3>See Also</h3>

<p><code><a href="roc.html">roc</a></code>, <code><a href="nea.render.html">nea.render</a></code>
</p>


<h3>Examples</h3>

<pre>
data(can.sig.go);
fpath &lt;- can.sig.go
gs.list &lt;- import.gs(fpath, Lowercase = 1, col.gene = 2, col.set = 3);
data(net.kegg)
netpath &lt;- net.kegg
net &lt;- import.net(netpath)

b0 &lt;- benchmark (NET = net,
 GS = gs.list, 
 echo=1, graph=TRUE, na.replace = 0, mask = ".", minN = 0,
 coff.z = 1.965, coff.fdr = 0.1, Parallelize=2);

## Not run: 
## Benchmark a number of networks on GO terms and KEGG pathways separately, using masks:
b1 &lt;- NULL;
for (mask in c("kegg_", "go_")) {
b1[[mask]] &lt;- NULL;
for (file.net in c("netpath")) {
# a series of networks can be put here: c("netpath1", "netpath2", "netpath3")
net &lt;- import.net(netpath, col.1 = 1, col.2 = 2, Lowercase = 1, echo = 1)
b1[[mask]][[file.net]] &lt;- benchmark (NET = net, GS = gs.list, echo=1, 
graph=FALSE, na.replace = 0, mask = mask, minN = 0,  Parallelize=1);
}}
par(mfrow=c(2,1));
roc(b1[["kegg_"]], coff.z = 2.57,main="kegg_");
roc(b1[["go_"]], coff.z = 2.57,main="go_");

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>NEArender</em> version 1.5 <a href="00Index.html">Index</a>]</div>
</body></html>
