<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: dplyr backend for any DBI-compatible database</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for src_dbi {dbplyr}"><tr><td>src_dbi {dbplyr}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>dplyr backend for any DBI-compatible database</h2>

<h3>Description</h3>

<p><code>src_dbi()</code> is a general dplyr backend that connects to any
DBI driver. <code>src_memdb()</code> connects to a temporary in-memory SQLite
database, that's useful for testing and experimenting.
</p>
<p>You can generate a <code>tbl()</code> directly from the DBI connection, or
go via <code>src_dbi()</code>.
</p>


<h3>Usage</h3>

<pre>
src_dbi(con, auto_disconnect = FALSE)

## S3 method for class 'src_dbi'
tbl(src, from, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>con</code></td>
<td>
<p>An object that inherits from <a href="../../DBI/html/DBIConnection-class.html">DBI::DBIConnection</a>,
typically generated by <a href="../../DBI/html/dbConnect.html">DBI::dbConnect</a></p>
</td></tr>
<tr valign="top"><td><code>auto_disconnect</code></td>
<td>
<p>Should the connection be automatically closed when
the src is deleted? Set to <code>TRUE</code> if you initialize the connection
the call to <code>src_dbi()</code>. Pass <code>NA</code> to auto-disconnect but print a message
when this happens.</p>
</td></tr>
<tr valign="top"><td><code>src</code></td>
<td>
<p>Either a <code>src_dbi</code> or <code>DBIConnection</code></p>
</td></tr>
<tr valign="top"><td><code>from</code></td>
<td>
<p>Either a string (giving a table name) or literal <code><a href="sql.html">sql()</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Needed for compatibility with generic; currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All data manipulation on SQL tbls are lazy: they will not actually
run the query or retrieve the data unless you ask for it: they all return
a new <code>tbl_dbi</code> object. Use <code><a href="../../dplyr/html/compute.html">compute()</a></code> to run the query and save the
results in a temporary in the database, or use <code><a href="../../dplyr/html/compute.html">collect()</a></code> to retrieve the
results to R. You can see the query with <code><a href="../../dplyr/html/explain.html">show_query()</a></code>.
</p>
<p>For best performance, the database should have an index on the variables
that you are grouping by. Use <code><a href="../../dplyr/html/explain.html">explain()</a></code> to check that the database is using
the indexes that you expect.
</p>
<p>There is one excpetion: <code><a href="../../dplyr/html/do.html">do()</a></code> is not lazy since it must pull the data
into R.
</p>


<h3>Value</h3>

<p>An S3 object with class <code>src_dbi</code>, <code>src_sql</code>, <code>src</code>.
</p>


<h3>Examples</h3>

<pre>
# Basic connection using DBI -------------------------------------------
library(dplyr)

con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
src &lt;- src_dbi(con, auto_disconnect = TRUE)

# Add some data
copy_to(src, mtcars)
src
DBI::dbListTables(con)

# To retrieve a single table from a source, use `tbl()`
src %&gt;% tbl("mtcars")

# You can also use pass raw SQL if you want a more sophisticated query
src %&gt;% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))

# Alternatively, you can use the `src_sqlite()` helper
src2 &lt;- src_sqlite(":memory:", create = TRUE)

# If you just want a temporary in-memory database, use src_memdb()
src3 &lt;- src_memdb()

# To show off the full features of dplyr's database integration,
# we'll use the Lahman database. lahman_sqlite() takes care of
# creating the database.

if (has_lahman("sqlite")) {
lahman_p &lt;- lahman_sqlite()
batting &lt;- lahman_p %&gt;% tbl("Batting")
batting

# Basic data manipulation verbs work in the same way as with a tibble
batting %&gt;% filter(yearID &gt; 2005, G &gt; 130)
batting %&gt;% select(playerID:lgID)
batting %&gt;% arrange(playerID, desc(yearID))
batting %&gt;% summarise(G = mean(G), n = n())

# There are a few exceptions. For example, databases give integer results
# when dividing one integer by another. Multiply by 1 to fix the problem
batting %&gt;%
  select(playerID:lgID, AB, R, G) %&gt;%
  mutate(
   R_per_game1 = R / G,
   R_per_game2 = R * 1.0 / G
 )

# All operations are lazy: they don't do anything until you request the
# data, either by `print()`ing it (which shows the first ten rows),
# or by `collect()`ing the results locally.
system.time(recent &lt;- filter(batting, yearID &gt; 2010))
system.time(collect(recent))

# You can see the query that dplyr creates with show_query()
batting %&gt;%
  filter(G &gt; 0) %&gt;%
  group_by(playerID) %&gt;%
  summarise(n = n()) %&gt;%
  show_query()
}
</pre>

<hr /><div style="text-align: center;">[Package <em>dbplyr</em> version 1.2.2 <a href="00Index.html">Index</a>]</div>
</body></html>
