<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Assessing Convergence for Fitted Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for convergence {lme4}"><tr><td>convergence {lme4}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Assessing Convergence for Fitted Models</h2>

<h3>Description</h3>

<p>The <span class="pkg">lme4</span> package uses general-purpose nonlinear optimizers
(e.g. Nelder-Mead or Powell's BOBYQA method) to estimate the
variance-covariance matrices of the random effects.  Assessing
reliably whether such algorithms have converged is difficult.  For
example, evaluating the
<a href="http://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">
Karush-Kuhn-Tucker conditions</a> (convergence criteria which in the
simplest case of non-constrained optimization reduce to showing that
the gradient is zero and the Hessian is positive definite) is
challenging because of the difficulty of evaluating the gradient and
Hessian.
</p>
<p>We (the <code>lme4</code> authors and maintainers) are still in the process
of finding the best strategies for testing convergence.  Some of the
relevant issues are
</p>

<ul>
<li><p> the gradient and Hessian are the basic ingredients of
KKT-style testing, but when they have to be estimated by finite
differences (as in the case of <code>lme4</code>; direct computation
of derivatives based on analytic expressions may eventually be
available for some special classes, but we have not yet
implemented them) they may not be sufficiently accurate for
reliable convergence testing.
</p>
</li>
<li><p> The Hessian computation in particular represents
a difficult tradeoff between computational expense and
accuracy.  At present the Hessian computations used
for convergence checking (and for estimating standard errors
of fixed-effect parameters for GLMMs) follow the <span class="pkg">ordinal</span> package
in using a naive but computationally cheap centered finite difference
computation (with a fixed step size of <i>1e-4</i>).  A more
reliable but more expensive approach is to use
<a href="http://en.wikipedia.org/wiki/Richardson_extrapolation">Richardson extrapolation</a>,
as implemented in the <span class="pkg">numDeriv</span> package.
</p>
</li>
<li><p> it is important to scale the estimated gradient at
the estimate appropriately; two reasonable approaches are
</p>

<ol>
<li><p> don't scale random-effects (Cholesky) gradients, since these
are essentially already unitless (for LMMs they are scaled
relative to the residual variance; for GLMMs they are scaled
relative to the sampling variance of the conditional distribution);
for GLMMs, scale fixed-effect gradients by the standard deviations
of the corresponding input variable, or
</p>
</li>
<li><p> scale gradients by the inverse Cholesky factor of the
Hessian, equivalent to scaling by the estimated Wald standard error
of the estimated parameters.  The latter approach is used in the
current version of <span class="pkg">lme4</span>; it has the disadvantage that it
requires us to estimate the Hessian (although the Hessian is
required <a href="https://github.com/lme4/lme4/issues/47">for
reliable estimation of the fixed-effect standard errors for GLMMs</a>
in any case).
</p>
</li></ol>

</li>
<li><p> Exploratory analyses suggest that (1) the naive estimation
of the Hessian may fail for large data sets (number of observations
greater than approximately
<i>1e5</i>); (2) the magnitude of the scaled
gradient increases with sample size, so that warnings will occur
even for apparently well-behaved fits with large data sets.
</p>
</li></ul>

<p>If you do see convergence warnings, and want to trouble-shoot/double-check
the results, the following steps are recommended (examples are given below):
</p>

<ul>
<li><p> double-check the model specification and the data
for mistakes
</p>
</li>
<li><p> center and scale continuous predictor variables (e.g. with
<code><a href="../../base/html/scale.html">scale</a></code>)
</p>
</li>
<li><p> check for singularity: if any of the diagonal elements of the
Cholesky factor are zero or very small, the convergence testing methods may be
inappropriate (see examples)
</p>
</li>
<li><p> double-check the Hessian calculation with the more expensive
Richardson extrapolation method (see examples)
</p>
</li>
<li><p> restart the fit from the apparent optimum, or from a point
perturbed slightly away from the optimum
</p>
</li>
<li><p> try all available optimizers (e.g. several different implementations
of BOBYQA and Nelder-Mead, L-BFGS-B from <code>optim</code>, <code>nlminb</code>,
...) via the <code><a href="allFit.html">allFit</a></code> function, see &lsquo;5.&rsquo; in the
examples.  While this will of course be slow for large fits, we consider
it the gold standard; if all optimizers converge to values that
are practically equivalent, then we would consider the convergence
warnings to be false positives.
</p>
</li></ul>

<p>To quote Douglas Adams,
<a href="http://en.wikipedia.org/wiki/So_Long,_and_Thanks_for_All_the_Fish">we
apologize for the inconvenience</a>.
</p>


<h3>See Also</h3>

<p><code><a href="lmerControl.html">lmerControl</a></code>, <code><a href="isSingular.html">isSingular</a></code></p>


<h3>Examples</h3>

<pre>
fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)

## 1. center and scale predictors:
ss.CS &lt;- transform(sleepstudy, Days=scale(Days))
fm1.CS &lt;- update(fm1, data=ss.CS)

## 2. check singularity
isSingular(fm1)

## 3. recompute gradient and Hessian with Richardson extrapolation
devfun &lt;- update(fm1, devFunOnly=TRUE)
if (isLMM(fm1)) {
    pars &lt;- getME(fm1,"theta")
} else {
    ## GLMM: requires both random and fixed parameters
    pars &lt;- getME(fm1, c("theta","fixef"))
}
if (require("numDeriv")) {
    cat("hess:\n"); print(hess &lt;- hessian(devfun, unlist(pars)))
    cat("grad:\n"); print(grad &lt;- grad(devfun, unlist(pars)))
    cat("scaled gradient:\n")
    print(scgrad &lt;- solve(chol(hess), grad))
}
## compare with internal calculations:
fm1@optinfo$derivs

## 4. restart the fit from the original value (or
## a slightly perturbed value):
fm1.restart &lt;- update(fm1, start=pars)

## 5. try all available optimizers

  fm1.all &lt;- allFit(fm1)
  ss &lt;- summary(fm1.all)
  ss$ fixef               ## extract fixed effects
  ss$ llik                ## log-likelihoods
  ss$ sdcor               ## SDs and correlations
  ss$ theta               ## Cholesky factors
  ss$ which.OK            ## which fits worked

</pre>

<hr /><div style="text-align: center;">[Package <em>lme4</em> version 1.1-19 <a href="00Index.html">Index</a>]</div>
</body></html>
